## ✅ 전체 목표

> Docker 컨테이너를 단순히 실행만 하는 수준을 넘어,
**직접 제어하고 내부에서 디버깅**까지 진행
> 

## 🔹 1. Docker 아키텍처 이해

| 구성요소  | 설명 |
| --- | --- |
| Docker CLI | 사용자가 터미널에서 명령어를 입력하는 인터페이스 |
| Docker Engine | CLI 명령을 받아 실제로 컨테이너를 실행 / 관리하는 백엔드 서비스 |
| 구조 | CLI → 요청 → Docker Engine → 이미지 / 컨테이너 관리 |

## 🔹 2. Docker Image vs Container

| 항목 | Image | Container |
| --- | --- | --- |
| 의미 | 실행 가능한 정적 패키지 | 이미지를 실행한 프로세스 |
| 상태 | 정적(변하지 않음) | 동적(실행 중이며 리소스 사용) |
| 비유 | `.zip` 압축 파일 | 압축 풀고 실제로 실행한 프로그램 상태 |
| 만들기 | `docker build` | `docker run` |

## 🔹 3. 핵심 명령어

| 명령어 | 설명 |
| --- | --- |
| `docker ps -a` | 실행 중 + 종료된 컨테이너 목록 확인 |
| `docker start 컨테이너명` | 중지된 컨테이너 다시 실행 |
| `docker exec -it 컨테이너명 bash` | 컨테이너 안으로 직접 들어가 bash 쉘 열기 |
| `ls` | 컨테이너 내 파일 시스템 확인 |
| `pip list` | 설치된 패키지 확인 |
| `exit` | 컨테이너 쉘 종료 후 나가기 |

## 🔹 4. 추가 개념

- **포트포워딩** : `-p 8000:8000`으로 로컬 PC와 컨테이너 연결
- **Dockerfile**은 실행 환경만 정의, 실행은 `docker run`때 생성
- **컨테이너는 백그라운드 프로세스** → 터미널 종료해도 계속 실행